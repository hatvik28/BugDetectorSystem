{
    "JUA_DONT_ASSERT_INSTANCEOF_IN_TESTS": "Asserting type checks in tests is discouraged; ClassCastException messages are more informative.",
    "AA_ASSERTION_OF_ARGUMENTS": "Assertions shouldn't validate arguments of public methods as they're ignored when assertions are disabled.",
    "CT_CONSTRUCTOR_THROW": "Avoid exceptions in constructors to prevent Finalizer attacks.",
    "CNT_ROUGH_CONSTANT_VALUE": "Use predefined library constants for precision and clarity.",
    "NP_BOOLEAN_RETURN_NULL": "Returning null for Boolean can cause NullPointerException due to auto-unboxing.",
    "SW_SWING_METHODS_INVOKED_IN_SWING_THREAD": "Swing methods like pack() should be invoked in the Swing thread to avoid threading issues.",
    "FI_FINALIZER_ONLY_NULLS_FIELDS": "Finalizers that only null fields are ineffective for garbage collection.",
    "FI_FINALIZER_NULLS_FIELDS": "Nulling fields in finalizers doesn’t aid garbage collection and is usually unnecessary.",
    "UI_INHERITANCE_UNSAFE_GETRESOURCE": "Using getResource in inherited classes can yield unexpected results.",
    "AM_CREATES_EMPTY_ZIP_FILE_ENTRY": "Calling putNextEntry() then closeEntry() without adding content results in an empty ZipFile entry.",
    "AM_CREATES_EMPTY_JAR_FILE_ENTRY": "Calling putNextEntry() then closeEntry() without content results in an empty JarFile entry.",
    "IMSE_DONT_CATCH_IMSE": "IllegalMonitorStateException usually indicates a design flaw; avoid catching it.",
    "CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE": "Class defines clone() but doesn’t implement Cloneable.",
    "CN_IDIOM": "Class implements Cloneable but does not define or use the clone method.",
    "CN_IDIOM_NO_SUPER_CALL": "clone() method does not call super.clone(), potentially breaking subclass cloning.",
    "DE_MIGHT_DROP": "This method might drop an exception without handling or reporting it.",
    "DE_MIGHT_IGNORE": "This method might ignore an exception without handling or reporting it.",
    "DM_EXIT": "Invoking System.exit terminates the JVM, which can be disruptive.",
    "NM_FUTURE_KEYWORD_USED_AS_IDENTIFIER": "Identifier is a keyword in later Java versions, causing future compatibility issues.",
    "NM_FUTURE_KEYWORD_USED_AS_MEMBER_IDENTIFIER": "Identifier used as a keyword in later Java versions, risking compatibility.",
    "JCIP_FIELD_ISNT_FINAL_IN_IMMUTABLE_CLASS": "Immutable classes should declare all fields as final.",
    "DM_RUN_FINALIZERS_ON_EXIT": "Avoid calling System.runFinalizersOnExit as it is highly dangerous.",
    "NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT": "equals() method should return false if the argument is null.",
    "FI_EMPTY": "Empty finalize() methods should be removed as they are unnecessary.",
    "FI_NULLIFY_SUPER": "Finalizer negates superclass finalizer's effects; delete if not intended.",
    "FI_USELESS": "Finalizer that only calls superclass finalize() is redundant and should be deleted.",
    "FI_MISSING_SUPER_CALL": "Finalizer omits call to superclass finalize(); add super.finalize().",
    "FI_EXPLICIT_INVOCATION": "Explicit finalize() calls are risky and may cause issues with VM handling.",
    "EQ_CHECK_FOR_OPERAND_NOT_COMPATIBLE_WITH_THIS": "equals() checks for incompatible types, which can lead to unexpected behavior.",
    "EQ_GETCLASS_AND_CLASS_CONSTANT": "equals() method compares class literal, which can break if subclassed.",
    "EQ_SELF_NO_OBJECT": "equals() method is covariant; parameter should be of type Object.",
    "CO_SELF_NO_OBJECT": "compareTo() method should use Object as parameter to correctly override Comparable.",
    "CO_COMPARETO_RESULTS_MIN_VALUE": "Returning Integer.MIN_VALUE in compareTo() can lead to incorrect behavior; use -1 instead.",
    "CO_COMPARETO_INCORRECT_FLOATING": "compareTo() for float or double should use Double.compare or Float.compare to handle NaN and -0.0 cases.",
    "RV_NEGATING_RESULT_OF_COMPARETO": "Negating compareTo() results is risky due to Integer.MIN_VALUE; reverse operand order instead.",
    "ES_COMPARING_STRINGS_WITH_EQ": "String comparison should use equals() instead of == or != for value equality.",
    "ES_COMPARING_PARAMETER_STRING_WITH_EQ": "String parameters should use equals() for comparison instead of == or !=.",
    "EQ_COMPARETO_USE_OBJECT_EQUALS": "compareTo() should be consistent with equals() to avoid unpredictable behavior in collections.",
    "HE_HASHCODE_USE_OBJECT_EQUALS": "Class defines hashCode() but uses Object.equals(), which may lead to unintended behavior in hash-based collections.",
    "HE_HASHCODE_NO_EQUALS": "Class defines hashCode() but not equals(), possibly violating equal objects having equal hashcodes.",
    "HE_EQUALS_USE_HASHCODE": "Class defines equals() but uses Object.hashCode(), risking inconsistent hash-based collections behavior.",
    "HE_INHERITS_EQUALS_USE_HASHCODE": "Class inherits equals() and uses Object.hashCode(), risking inconsistent behavior in collections.",
    "HE_EQUALS_NO_HASHCODE": "Class defines equals() without hashCode(), risking equality-hashcode inconsistency.",
    "EQ_ABSTRACT_SELF": "Abstract class defines a covariant equals() method, potentially breaking Object.equals()'s contract.",
    "CO_ABSTRACT_SELF": "Abstract class defines covariant compareTo(), should use Object for correct Comparable interface override.",
    "IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION": "Superclass uses subclass during initialization, which can lead to null references.",
    "SI_INSTANCE_BEFORE_FINALS_ASSIGNED": "Static initializer creates instance before all static final fields are assigned, which can lead to incomplete initialization.",
    "IT_NO_SUCH_ELEMENT": "Iterator next() method doesn’t throw NoSuchElementException as expected when no more elements are available.",
    "ME_MUTABLE_ENUM_FIELD": "Public enum has a mutable field, risking unintended changes from other packages.",
    "ME_ENUM_FIELD_SETTER": "Public enum method unconditionally sets a field, risking changes from external packages.",
    "NM_METHOD_NAMING_CONVENTION": "Methods should start with a lowercase letter and use camel case, with verbs describing actions.",
    "NM_FIELD_NAMING_CONVENTION": "Non-final fields should use camel case, while final fields should be uppercase with underscores.",
    "NM_SAME_SIMPLE_NAME_AS_INTERFACE": "Class/interface name should not match an implemented interface name from a different package to avoid confusion.",
    "NM_SAME_SIMPLE_NAME_AS_SUPERCLASS": "Class name should not match a superclass name from a different package to avoid confusion.",
    "NM_CLASS_NAMING_CONVENTION": "Class names should start with an uppercase letter and use camel case, ideally with descriptive nouns.",
    "NM_VERY_CONFUSING_INTENTIONAL": "Method names differ only by capitalization, making it unclear which method overrides another.",
    "NM_WRONG_PACKAGE_INTENTIONAL": "Method doesn’t override a superclass method due to different parameter package, which is confusing and should be clarified.",
    "NM_CONFUSING": "Method names that differ only by capitalization may cause confusion.",
    "NM_CLASS_NOT_EXCEPTION": "Class named as an exception but not derived from Exception, potentially confusing users of this class.",
    "RR_NOT_CHECKED": "Method ignores result of InputStream.read(), which can lead to incorrect data handling if fewer bytes are read than requested.",
    "SR_NOT_CHECKED": "Method ignores result of InputStream.skip(), risking incomplete data processing if fewer bytes are skipped than expected.",
    "SE_NO_SUITABLE_CONSTRUCTOR": "Serializable class's superclass lacks a void constructor, which can cause deserialization failures.",
    "SE_NO_SUITABLE_CONSTRUCTOR_FOR_EXTERNALIZATION": "Externalizable class lacks a void constructor, preventing correct deserialization.",
    "SE_COMPARATOR_SHOULD_BE_SERIALIZABLE": "Comparator should implement Serializable to ensure proper serialization of sorted collections like TreeMap.",
    "SE_NO_SERIALVERSIONID": "Serializable class lacks a serialVersionUID, risking version compatibility issues across different JVMs.",
    "SE_READ_RESOLVE_MUST_RETURN_OBJECT": "The readResolve method must return an Object to be recognized by the serialization mechanism.",
    "SE_TRANSIENT_FIELD_NOT_RESTORED": "Transient field not restored during deserialization, resulting in a default value rather than the intended state.",
    "SE_PREVENT_EXT_OBJ_OVERWRITE": "readExternal() method should be protected against unintentional or malicious overwriting of Externalizable objects.",
    "SE_NONFINAL_SERIALVERSIONID": "serialVersionUID should be final to ensure it remains unchanged across versions.",
    "SE_NONSTATIC_SERIALVERSIONID": "serialVersionUID should be static for proper serialization control.",
    "SE_NONLONG_SERIALVERSIONID": "serialVersionUID should be of type long to match serialization requirements.",
    "SE_BAD_FIELD": "Serializable class has non-transient, non-Serializable field, which may not deserialize correctly if non-serializable data is stored.",
    "SE_INNER_CLASS": "Serializable inner classes may serialize unintended outer class data; making the inner class static can prevent this.",
    "SE_BAD_FIELD_INNER_CLASS": "Serializable inner class of a non-serializable outer class can cause runtime errors; making the inner class static or serializing the outer class may solve this.",
    "SE_BAD_FIELD_STORE": "Non-serializable value stored in a non-transient field of a serializable class, which may cause serialization issues.",
    "RV_RETURN_VALUE_IGNORED_BAD_PRACTICE": "Method ignores return value, which may indicate failure or unexpected behavior (e.g., File.delete() failing silently).",
    "NP_TOSTRING_COULD_RETURN_NULL": "toString method may return null, potentially causing unexpected behavior; return an empty or appropriate string instead.",
    "NP_CLONE_COULD_RETURN_NULL": "clone method may return null, which is not allowed; use AssertionError if path is unreachable.",
    "OS_OPEN_STREAM": "Method may fail to close IO stream, potentially causing resource leaks; use finally or try-with-resources to close streams.",
    "OS_OPEN_STREAM_EXCEPTION_PATH": "Method may not close IO stream on exception paths, risking resource leaks; close streams in finally or try-with-resources.",
    "RC_REF_COMPARISON_BAD_PRACTICE": "Suspicious reference comparison to constant using '=='; use .equals() instead to avoid incorrect comparisons.",
    "RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN": "Boolean values compared with '==', potentially causing incorrect behavior; use .equals() to check equality.",
    "VA_FORMAT_STRING_USES_NEWLINE": "Format string includes \\n; use %n instead for platform-specific line separators.",
    "BIT_SIGNED_CHECK": "Checks sign of bitwise operation with '> 0', which can misbehave; use '!= 0' for clarity and correctness.",
    "ODR_OPEN_DATABASE_RESOURCE": "Database resource not closed on all paths, risking performance issues; ensure resources are closed to avoid connection leaks.",
    "ODR_OPEN_DATABASE_RESOURCE_EXCEPTION_PATH": "Database resource may not close on exception paths, risking leaks; close resources in finally or try-with-resources.",
    "ISC_INSTANTIATE_STATIC_CLASS": "Needless instantiation of class with only static methods; access static methods directly without creating an instance.",
    "DMI_RANDOM_USED_ONLY_ONCE": "Random object created and used once, which is inefficient; reuse Random object or consider SecureRandom for stronger randomness.",
    "BC_EQUALS_METHOD_SHOULD_WORK_FOR_ALL_OBJECTS": "The equals(Object o) method should not assume anything about the type of o. It should return false if o is not of the same type as this.",
    "J2EE_STORE_OF_NON_SERIALIZABLE_OBJECT_INTO_SESSION": "Storing a non-serializable object in an HttpSession can lead to errors if the session is passivated or migrated.",
    "GC_UNCHECKED_TYPE_IN_GENERIC_CALL": "Passing an Object where a specific type is expected in a generic method call leads to unchecked type warnings.",
    "PZ_DONT_REUSE_ENTRY_OBJECTS_IN_ITERATORS": "Reusing entry objects in iterators can cause errors; avoid modifying collections during iteration.",
    "DMI_ENTRY_SETS_MAY_REUSE_ENTRY_OBJECTS": "Entry sets may reuse entry objects, leading to unexpected behavior if iterated multiple times.",
    "DMI_USING_REMOVEALL_TO_CLEAR_COLLECTION": "Use c.clear() to remove all elements from a collection instead of c.removeAll(c).",
    "THROWS_METHOD_THROWS_RUNTIMEEXCEPTION": "Throwing RuntimeException directly makes recovery from errors difficult; consider more specific exceptions.",
    "THROWS_METHOD_THROWS_CLAUSE_BASIC_EXCEPTION": "Use more specific exceptions in the throws clause instead of Exception to avoid forcing unnecessary handling.",
    "THROWS_METHOD_THROWS_CLAUSE_THROWABLE": "Avoid using Throwable in the throws clause as it includes Errors, which indicate unrecoverable scenarios.",
    "PA_PUBLIC_PRIMITIVE_ATTRIBUTE": "Public primitive fields should be avoided; make fields private and use setters if necessary.",
    "PA_PUBLIC_ARRAY_ATTRIBUTE": "Public array-type fields can lead to unexpected modifications; consider making them private.",
    "PA_PUBLIC_MUTABLE_OBJECT_ATTRIBUTE": "Public mutable object-type fields should be avoided; make fields private and use setters.",
    "PI_DO_NOT_REUSE_PUBLIC_IDENTIFIERS_CLASS_NAMES": "Avoid reusing public identifiers from the Java Standard Library as class names to prevent naming conflicts.",
    "PI_DO_NOT_REUSE_PUBLIC_IDENTIFIERS_FIELD_NAMES": "Avoid using public Java Standard Library identifiers as field names to prevent confusion and conflicts.",
    "PI_DO_NOT_REUSE_PUBLIC_IDENTIFIERS_METHOD_NAMES": "Avoid reusing Java Standard Library identifiers as method names to reduce conflicts and ensure clarity.",
    "PI_DO_NOT_REUSE_PUBLIC_IDENTIFIERS_LOCAL_VARIABLE_NAMES": "Do not reuse public identifiers from the Java Standard Library as local variable names to avoid confusion and naming conflicts.",
    "ENV_USE_PROPERTY_INSTEAD_OF_ENV": "Use Java properties (System.getProperty) instead of environment variables (System.getenv) for portability and consistency across platforms.",
    "OVERRIDING_METHODS_MUST_INVOKE_SUPER": "Super method annotated with @OverridingMethodsMustInvokeSuper should be called in the overriding method.",
    "NP_OPTIONAL_RETURN_NULL": "Do not return null when the method is supposed to return an Optional value, as it breaks the design contract.",
    "NP_NONNULL_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR": "Non-null fields must be initialized in the constructor to avoid null pointer issues.",
    "VR_UNRESOLVABLE_REFERENCE": "The class refers to an unresolvable class or method, likely causing errors during compilation.",
    "IL_INFINITE_LOOP": "Loops without a termination condition, causing infinite loops.",
    "IO_APPENDING_TO_OBJECT_OUTPUT_STREAM": "Appending to an ObjectOutputStream is not supported. Consider using a different approach for appending data.",
    "IL_INFINITE_RECURSIVE_LOOP": "The method calls itself unconditionally, leading to a potential stack overflow due to infinite recursion.",
    "IL_CONTAINER_ADDED_TO_ITSELF": "Adding a collection to itself will cause a stack overflow when computing its hashCode.",
    "RpC_REPEATED_CONDITIONAL_TEST": "Avoid repeating conditional tests with identical conditions in succession.",
    "FL_MATH_USING_FLOAT_PRECISION": "Using floating-point math can lead to imprecision. Consider using double for more accurate calculations.",
    "CAA_COVARIANT_ARRAY_ELEMENT_STORE": "Storing incompatible elements in a covariant array may cause ArrayStoreException at runtime.",
    "DMI_VACUOUS_CALL_TO_EASYMOCK_METHOD": "Calling EasyMock methods without passing objects is ineffective.",
    "DMI_FUTILE_ATTEMPT_TO_CHANGE_MAXPOOL_SIZE_OF_SCHEDULED_THREAD_POOL_EXECUTOR": "Changing max pool size in ScheduledThreadPoolExecutor has no effect as it is a fixed-size pool.",
    "DMI_BIGDECIMAL_CONSTRUCTED_FROM_DOUBLE": "Creating BigDecimal from a double directly may result in precision issues. Use BigDecimal.valueOf(double) instead.",
    "DMI_SCHEDULED_THREAD_POOL_EXECUTOR_WITH_ZERO_CORE_THREADS": "A ScheduledThreadPoolExecutor with zero core threads cannot execute tasks.",
    "DMI_ANNOTATION_IS_NOT_VISIBLE_TO_REFLECTION": "Annotations with non-runtime retention cannot be accessed using reflection.",
    "NP_ARGUMENT_MIGHT_BE_NULL": "Always check for null before dereferencing arguments that might be null.",
    "RV_ABSOLUTE_VALUE_OF_RANDOM_INT": "Calculating absolute value of random integer may fail for Integer.MIN_VALUE due to overflow.",
    "RV_ABSOLUTE_VALUE_OF_HASHCODE": "Calculating absolute value of hashcode can result in an overflow if hashcode is Integer.MIN_VALUE.",
    "RV_01_TO_INT": "Coercing a random value from 0 to 1 directly into an integer results in 0. Multiply the value or use Random.nextInt(n).",
    "DM_INVALID_MIN_MAX": "Incorrect use of Math.min and Math.max; reorder the constants for correct functionality.",
    "EQ_COMPARING_CLASS_NAMES": "Equals method compares class names instead of class objects. Use class objects for accurate comparison.",
    "EQ_ALWAYS_TRUE": "Equals method always returns true, breaking symmetry and proper object comparison.",
    "EQ_ALWAYS_FALSE": "Equals method always returns false, making it impossible to create useful Maps or Sets.",
    "EQ_OVERRIDING_EQUALS_NOT_SYMMETRIC": "Overriding equals may not be symmetric when using instanceof, causing incorrect equality checks.",
    "EQ_DONT_DEFINE_EQUALS_FOR_ENUM": "Avoid defining a covariant equals method in enums to prevent inconsistent equality behavior.",
    "EQ_SELF_USE_OBJECT": "Covariant equals method is defined, but Object.equals is inherited. Define equals(Object) explicitly.",
    "EQ_OTHER_USE_OBJECT": "Equals method does not override Object.equals but inherits one from a superclass. Override equals(Object).",
    "EQ_OTHER_NO_OBJECT": "Equals method does not override Object.equals and inherits equals(Object). Override it explicitly.",
    "HE_SIGNATURE_DECLARES_HASHING_OF_UNHASHABLE_CLASS": "A class with a non-hashable type is used in a hashed context. Ensure hashCode is implemented.",
    "HE_USE_OF_UNHASHABLE_CLASS": "A class defines equals but not hashCode, violating the hashCode contract in hashed data structures.",
    "UR_UNINIT_READ": "A field is read before being initialized in the constructor, which could lead to errors.",
    "UR_UNINIT_READ_CALLED_FROM_SUPER_CONSTRUCTOR": "Method in superclass constructor reads an uninitialized field, causing potential errors.",
    "NM_VERY_CONFUSING": "Methods differ only by capitalization, which is confusing and can cause issues with overriding.",
    "NM_WRONG_PACKAGE": "Method doesn't override superclass method due to a mismatch in parameter package.",
    "NM_METHOD_CONSTRUCTOR_CONFUSION": "A method shares the class name, likely intended as a constructor. Remove void return type if it's a constructor.",
    "NM_LCASE_HASHCODE": "The method 'hashcode()' should be renamed to 'hashCode()' to correctly override the hashCode() method from java.lang.Object.",
    "NM_LCASE_TOSTRING": "The method 'tostring()' should be renamed to 'toString()' to correctly override the toString() method from java.lang.Object.",
    "NM_BAD_EQUAL": "The method 'equal(Object)' should be renamed to 'equals(Object)' to correctly override the equals(Object) method from java.lang.Object.",
    "SE_READ_RESOLVE_IS_STATIC": "The readResolve method must not be static to be recognized by the serialization mechanism.",
    "SE_METHOD_MUST_BE_PRIVATE": "For serialization to work properly, custom serialization/deserialization methods must be private.",
    "SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH": "A value is overwritten in a switch statement due to fall-through. Ensure breaks or returns are used.",
    "SF_DEAD_STORE_DUE_TO_SWITCH_FALLTHROUGH_TO_THROW": "A value is ignored in a switch case due to fall-through to a throw statement.",
    "NP_UNWRITTEN_FIELD": "A field is dereferenced without being initialized, which could lead to a NullPointerException.",
    "UWF_NULL_FIELD": "A field is only set to null, which renders it effectively useless.",
    "UWF_UNWRITTEN_FIELD": "A field is never written to, meaning it always holds its default value. Check for errors or remove it.",
    "SIC_THREADLOCAL_DEADLY_EMBRACE": "A non-static inner class could cause a deadly embrace with a thread-local variable, leading to memory leaks.",
    "RANGE_ARRAY_INDEX": "An array index is out of bounds, which will result in ArrayIndexOutOfBoundsException.",
    "RANGE_ARRAY_OFFSET": "An offset used in an array operation is out of bounds, causing IndexOutOfBoundsException.",
    "RANGE_ARRAY_LENGTH": "An array length is out of bounds, leading to IndexOutOfBoundsException.",
    "RANGE_STRING_INDEX": "A string index is out of bounds, causing StringIndexOutOfBoundsException.",
    "RV_RETURN_VALUE_IGNORED": "A method's return value is ignored when it should be checked, such as with immutable objects like String.",
    "RV_EXCEPTION_NOT_THROWN": "An exception object is created but not thrown. It likely needs to be thrown using 'throw'.",
    "RV_CHECK_COMPARETO_FOR_SPECIFIC_RETURN_VALUE": "The code checks for specific return values from compareTo, but only the sign of the result should be checked.",
    "NP_ALWAYS_NULL": "A null pointer is dereferenced, leading to a NullPointerException.",
    "NP_CLOSING_NULL": "The close() method is called on a value that is always null, risking a NullPointerException.",
    "NP_STORE_INTO_NONNULL_FIELD": "A nullable value is stored into a field annotated as @Nonnull.",
    "NP_ALWAYS_NULL_EXCEPTION": "A null pointer is dereferenced on an exception path, leading to a potential NullPointerException.",
    "NP_NULL_ON_SOME_PATH": "A null pointer dereference is guaranteed on some branch, leading to a possible NullPointerException.",
    "NP_NULL_ON_SOME_PATH_EXCEPTION": "A null pointer dereference occurs on some exception path, which may cause a NullPointerException.",
    "NP_NULL_PARAM_DEREF": "A null value is passed to a method parameter that should never be null.",
    "NP_NULL_PARAM_DEREF_NONVIRTUAL": "A potentially null value is passed to a non-null method parameter.",
    "NP_NULL_PARAM_DEREF_ALL_TARGETS_DANGEROUS": "A null value is passed to a method where all target methods require a non-null parameter.",
    "NP_NONNULL_PARAM_VIOLATION": "A null value is passed to a method that requires a non-null parameter.",
    "NP_NONNULL_RETURN_VIOLATION": "A method is declared to return @Nonnull but may return null.",
    "NP_GUARANTEED_DEREF": "A null value is guaranteed to be dereferenced at this point, which will cause a NullPointerException.",
    "NP_GUARANTEED_DEREF_ON_EXCEPTION_PATH": "A null value is guaranteed to be dereferenced on an exception path, leading to a possible NullPointerException.",
    "DMI_ARGUMENTS_WRONG_ORDER": "Method arguments appear to be in the wrong order, which could cause incorrect behavior.",
    "RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE": "A null check is redundant because the value has already been dereferenced and would have thrown a NullPointerException.",
    "RC_REF_COMPARISON": "References are compared using '==' or '!=' when they should be compared using equals(), especially for wrapper types.",
    "VA_PRIMITIVE_ARRAY_PASSED_TO_OBJECT_VARARG": "A primitive array is passed to a function that expects a variable number of object arguments, which creates unnecessary array wrapping.",
    "EC_UNRELATED_TYPES_USING_POINTER_EQUALITY": "Pointer equality is used to compare two references of unrelated types, which will always evaluate to false.",
    "EC_UNRELATED_TYPES": "equals() is called on two objects of different types, which may violate the symmetry contract of equals().",
    "EC_ARRAY_AND_NONARRAY": "equals() compares an array with a non-array, which will always return false. Use java.util.Arrays.equals() for array comparisons.",
    "EC_NULL_ARG": "equals() is called with null, which will always return false according to its contract.",
    "EC_UNRELATED_INTERFACES": "equals() compares two unrelated interface types, which will always return false.",
    "EC_UNRELATED_CLASS_AND_INTERFACE": "equals() compares a class and an interface that aren't related, always returning false.",
    "SA_LOCAL_SELF_ASSIGNMENT_INSTEAD_OF_FIELD": "A local variable is self-assigned instead of being assigned to a field, which is likely an error.",
    "INT_BAD_COMPARISON_WITH_INT_VALUE": "An int is compared with a long constant that exceeds the int range, which is incorrect.",
    "INT_BAD_COMPARISON_WITH_SIGNED_BYTE": "A signed byte is compared with a value outside its valid range, which is incorrect.",
    "INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE": "A non-negative value is compared with a negative constant, which is incorrect.",
    "BIT_ADD_OF_SIGNED_BYTE": "Sign-extended byte values are added incorrectly, leading to incorrect results.",
    "BIT_IOR_OF_SIGNED_BYTE": "Bitwise OR on a signed byte results in sign extension, causing errors. Use masking to avoid issues.",
    "BIT_SIGNED_CHECK_HIGH_BIT": "A bitwise expression compares with a negative constant using '>', which can lead to incorrect results. Use '!= 0' instead.",
    "BIT_AND": "A bitwise AND operation is performed with incompatible masks, always yielding false and possibly indicating a bug.",
    "BIT_AND_ZZ": "A bitwise AND operation compares with 0, always yielding true, which likely indicates a mistake.",
    "BIT_IOR": "A bitwise OR operation is performed with incompatible masks, always yielding false, indicating a possible logic error.",
    "SA_FIELD_SELF_ASSIGNMENT": "A field is self-assigned, which is useless and may indicate a logic error.",
    "SA_FIELD_SELF_COMPUTATION": "A field is involved in a nonsensical self-computation (e.g., x&x or x-x), which is likely a logic error.",
    "SA_LOCAL_SELF_COMPUTATION": "A local variable is involved in a nonsensical self-computation (e.g., x&x or x-x), indicating a possible typo.",
    "SA_FIELD_SELF_COMPARISON": "A field is compared with itself, which may indicate a logic error or typo.",
    "SA_LOCAL_SELF_COMPARISON": "A local variable is compared with itself, indicating a possible typo or logic error.",
    "UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS": "An anonymous class defines an uncallable method, which may be dead code or an override typo.",
    "IJU_ASSERT_METHOD_INVOKED_FROM_RUN_METHOD": "A JUnit assertion in the run() method won't be noticed if the test is running in a separate thread.",
    "IJU_BAD_SUITE_METHOD": "A JUnit TestCase defines a bad suite() method. It must be static and return either junit.framework.Test or TestSuite.",
    "IJU_SETUP_NO_SUPER": "The setUp method in JUnit TestCase does not call super.setUp(), which should be done.",
    "IJU_TEARDOWN_NO_SUPER": "The tearDown method in JUnit TestCase does not call super.tearDown(), which should be done.",
    "IJU_SUITE_NOT_STATIC": "The suite() method in JUnit TestCase is not static, which is incorrect.",
    "IJU_NO_TESTS": "A JUnit TestCase has no implemented test methods.",
    "BOA_BADLY_OVERRIDDEN_ADAPTER": "A method overrides a parent Adapter class method incorrectly, preventing the event handler from being called.",
    "SQL_BAD_RESULTSET_ACCESS": "Accessing a result set field with index 0, which is invalid since indexing starts at 1.",
    "SQL_BAD_PREPARED_STATEMENT_ACCESS": "Accessing a prepared statement parameter with index 0, which is invalid since parameter indexes start at 1.",
    "SIO_SUPERFLUOUS_INSTANCEOF": "Using instanceof where the object's type is already known, making the check unnecessary.",
    "BAC_BAD_APPLET_CONSTRUCTOR": "An Applet constructor relies on an uninitialized AppletStub, which causes method calls to fail.",
    "EC_INCOMPATIBLE_ARRAY_COMPARE": "equals() is used to compare incompatible arrays, which will always return false.",
    "EC_BAD_ARRAY_COMPARE": "Calling equals() on arrays is equivalent to ==, comparing references. Use Arrays.equals() for content comparison.",
    "STI_INTERRUPTED_ON_CURRENTTHREAD": "Calling currentThread() just to invoke interrupted() is unnecessary; use Thread.interrupted() instead.",
    "STI_INTERRUPTED_ON_UNKNOWNTHREAD": "Thread.interrupted() is called on a Thread instance that isn't the current thread, which may cause unexpected behavior.",
    "DLS_DEAD_LOCAL_INCREMENT_IN_RETURN": "Using x++ or x-- in a return statement has no effect, as the value is returned before the increment/decrement.",
    "DLS_DEAD_STORE_OF_CLASS_LITERAL": "Assigning a class literal to a variable that is never used, which behaves differently in Java 1.4 vs 5+.",
    "IP_PARAMETER_IS_DEAD_BUT_OVERWRITTEN": "A method parameter is overwritten, rendering its initial value irrelevant.",
    "MF_METHOD_MASKS_FIELD": "A local variable in a method has the same name as a field, potentially causing confusion or errors.",
    "MF_CLASS_MASKS_FIELD": "A field in a class masks a superclass field, leading to potential logical issues.",
    "FE_TEST_IF_EQUAL_TO_NOT_A_NUMBER": "Checking for equality with NaN always returns false. Use Double.isNaN() instead.",
    "ICAST_INT_2_LONG_AS_INSTANT": "Converting int to long for absolute time calculations may lead to errors for dates beyond 2037.",
    "ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL": "Casting an int to double before passing it to Math.ceil() is unnecessary and has no effect.",
    "ICAST_INT_CAST_TO_FLOAT_PASSED_TO_ROUND": "Casting an int to float before passing it to Math.round() is unnecessary and has no effect.",
    "NP_NULL_INSTANCEOF": "Checking if a null value is an instance of a class will always return false.",
    "DMI_LONG_BITS_TO_DOUBLE_INVOKED_ON_INT": "Calling Double.longBitsToDouble with an int value will likely produce incorrect results.",
    "BC_IMPOSSIBLE_CAST": "An impossible cast will always throw a ClassCastException.",
    "BC_IMPOSSIBLE_DOWNCAST": "An impossible downcast will always throw a ClassCastException.",
    "BC_IMPOSSIBLE_DOWNCAST_OF_TOARRAY": "Casting the result of toArray() to a specific type, such as String[], will often fail.",
    "BC_IMPOSSIBLE_INSTANCEOF": "An instanceof test will always return false, indicating a possible logic error.",
    "RE_POSSIBLE_UNINTENDED_PATTERN": "Using '.' or '|' in a regular expression may not behave as expected.",
    "RE_BAD_SYNTAX_FOR_REGULAR_EXPRESSION": "The code contains an invalid regular expression, which will throw a PatternSyntaxException.",
    "RE_CANT_USE_FILE_SEPARATOR_AS_REGULAR_EXPRESSION": "Using File.separator in regular expressions can cause issues on Windows due to backslash escaping.",
    "DLS_OVERWRITTEN_INCREMENT": "An increment or decrement operation is overwritten immediately, making it ineffective.",
    "ICAST_BAD_SHIFT_AMOUNT": "Shifting a 32-bit int by more than 31 or less than -31 leads to unexpected behavior.",
    "BSHIFT_WRONG_ADD_PRIORITY": "Shift operations in expressions might be parsed incorrectly due to operator precedence.",
    "IM_MULTIPLYING_RESULT_OF_IREM": "Multiplying the result of a remainder operation may lead to unexpected results due to operator precedence.",
    "DMI_INVOKING_HASHCODE_ON_ARRAY": "Calling hashCode on an array returns identity hash code, not based on array contents.",
    "DMI_INVOKING_TOSTRING_ON_ARRAY": "Calling toString on an array produces a non-informative result. Use Arrays.toString for better output.",
    "DMI_INVOKING_TOSTRING_ON_ANONYMOUS_ARRAY": "Calling toString on an anonymous array produces a non-informative result.",
    "DMI_BAD_MONTH": "A constant month value outside the expected range (0-11) is passed.",
    "DMI_CALLING_NEXT_FROM_HASNEXT": "Calling next() inside hasNext() is incorrect as hasNext() should not change iterator state.",
    "QBA_QUESTIONABLE_BOOLEAN_ASSIGNMENT": "Assigning a boolean literal inside a condition, instead of a comparison, likely indicates a mistake.",
    "GC_UNRELATED_TYPES": "Passing an incompatible argument to a generic collection method likely leads to errors.",
    "DMI_VACUOUS_SELF_COLLECTION_CALL": "Calling containsAll or retainAll on a collection with itself is pointless and redundant.",
    "DMI_DOH": "The method call is nonsensical and likely a mistake.",
    "DMI_COLLECTIONS_SHOULD_NOT_CONTAIN_THEMSELVES": "Passing a collection to a method that checks for containment of itself likely results in issues.",
    "TQ_UNKNOWN_VALUE_USED_WHERE_ALWAYS_STRICTLY_REQUIRED": "A value without a strict type qualifier is used in a context that requires it.",
    "TQ_COMPARING_VALUES_WITH_INCOMPATIBLE_TYPE_QUALIFIERS": "A value with a type qualifier (e.g., @NonNegative) is compared with one having a conflicting type qualifier (e.g., @Negative).",
    "TQ_ALWAYS_VALUE_USED_WHERE_NEVER_REQUIRED": "A value annotated as 'always' is used in a context requiring 'never'.",
    "TQ_NEVER_VALUE_USED_WHERE_ALWAYS_REQUIRED": "A value annotated as 'never' is used in a context requiring 'always'.",
    "TQ_MAYBE_SOURCE_VALUE_REACHES_ALWAYS_SINK": "A value that might not carry a type qualifier reaches a location where it must carry that qualifier.",
    "TQ_MAYBE_SOURCE_VALUE_REACHES_NEVER_SINK": "A value that might carry a type qualifier reaches a location where it must not carry that qualifier.",
    "FB_UNEXPECTED_WARNING": "SpotBugs generated a warning that shouldn't have appeared due to a @NoWarning annotation.",
    "FB_MISSING_EXPECTED_WARNING": "SpotBugs failed to generate a warning that should have been present according to an @ExpectedWarning annotation.",
    "EOS_BAD_END_OF_STREAM_CHECK": "Converting stream data to byte or char before comparing to -1 can cause incorrect loop behavior.",
    "FL_FLOATS_AS_LOOP_COUNTERS": "Floating-point variables shouldn't be used as loop counters due to precision issues.",
    "SING_SINGLETON_IMPLEMENTS_CLONEABLE": "A singleton class directly implements Cloneable, violating the singleton pattern.",
    "SING_SINGLETON_INDIRECTLY_IMPLEMENTS_CLONEABLE": "A singleton class indirectly implements Cloneable, violating the singleton pattern.",
    "SING_SINGLETON_IMPLEMENTS_CLONE_METHOD": "A singleton class implements clone() without unconditionally throwing CloneNotSupportedException, violating the singleton pattern.",
    "SING_SINGLETON_HAS_NONPRIVATE_CONSTRUCTOR": "A singleton class has a non-private constructor, violating the singleton pattern.",
    "SING_SINGLETON_IMPLEMENTS_SERIALIZABLE": "A singleton class implements Serializable, which allows multiple instances to be created via deserialization.",
    "SING_SINGLETON_GETTER_NOT_SYNCHRONIZED": "The instance getter of a singleton class is not synchronized, allowing multiple instances to be created in multithreaded environments.",
    "SKIPPED_CLASS_TOO_BIG": "The class is too large for effective analysis and was not fully checked for errors.",
    "UNKNOWN": "SpotBugs recorded a warning but could not find a description for it.",
    "TESTING": "A bug pattern generated by incomplete detectors for testing purposes.",
    "OBL_UNSATISFIED_OBLIGATION": "Method may fail to clean up resources (e.g., streams) properly, potentially leading to resource leaks.",
    "OBL_UNSATISFIED_OBLIGATION_EXCEPTION_EDGE": "Method may fail to clean up resources when an exception occurs, causing resource leaks.",
    "LG_LOST_LOGGER_DUE_TO_WEAK_REFERENCE": "OpenJDK's use of weak references for loggers may cause log configurations to be lost if the logger is garbage collected.",
    "DM_CONVERT_CASE": "String conversion to upper/lower case uses the platform's default encoding. Use Locale-based methods to handle international characters.",
    "DM_DEFAULT_ENCODING": "A method uses the platform's default encoding for byte-to-String conversions, causing potential cross-platform issues.",
    "MALICIOUS_CODE": "Code is vulnerable to attacks from untrusted code.",
    "DP_DO_INSIDE_DO_PRIVILEGED": "A method that requires security checks should be invoked inside a doPrivileged block.",
    "DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED": "Classloader creation should be inside a doPrivileged block if security permissions are needed.",
    "FI_PUBLIC_SHOULD_BE_PROTECTED": "The finalize() method should be protected, not public.",
    "MS_EXPOSE_REP": "Public static methods returning mutable objects/arrays may expose internal state. Consider returning copies.",
    "MS_EXPOSE_BUF": "Public static methods returning buffers may expose internal state. Use read-only buffers or copies.",
    "EI_EXPOSE_REP": "Returning references to mutable objects exposes internal state. Return copies when possible.",
    "EI_EXPOSE_BUF": "Returning references to buffers exposes internal state. Use read-only buffers or copies.",
    "EI_EXPOSE_REP2": "Storing references to mutable objects exposes internal state. Use copies.",
    "EI_EXPOSE_STATIC_REP2": "Storing references to mutable objects in static fields exposes internal state. Use copies.",
    "EI_EXPOSE_BUF2": "Creating buffers that store references to external arrays exposes internal state. Use copies.",
    "EI_EXPOSE_STATIC_BUF2": "Creating buffers that store references to external arrays in static fields exposes internal state. Use copies.",
    "MS_OOI_PKGPROTECT": "Mutable static fields in interfaces should be moved to classes and made package-protected.",
    "MS_FINAL_PKGPROTECT": "Mutable static fields should be made final and package-protected to avoid external modifications.",
    "MS_SHOULD_BE_FINAL": "Non-final static fields should be made final to prevent malicious modifications.",
    "MS_SHOULD_BE_REFACTORED_TO_BE_FINAL": "Static fields with multiple writes need refactoring to be made final.",
    "MS_PKGPROTECT": "Mutable static fields should be package-protected to prevent external modifications.",
    "MS_MUTABLE_HASHTABLE": "Final static fields referencing mutable Hashtables are vulnerable to modifications.",
    "MS_MUTABLE_ARRAY": "Final static fields referencing mutable arrays are vulnerable to modifications.",
    "MS_MUTABLE_COLLECTION": "Final static fields referencing mutable collections are vulnerable to modifications.",
    "MS_MUTABLE_COLLECTION_PKGPROTECT": "Final static fields referencing mutable collections should be package-protected.",
    "MS_CANNOT_BE_FINAL": "Mutable static fields cannot be made final, but their use should be protected.",
    "REFLC_REFLECTION_MAY_INCREASE_ACCESSIBILITY_OF_CLASS": "Using reflection to instantiate a class can increase its accessibility, exposing private constructors. Avoid using reflection this way.",
    "REFLF_REFLECTION_MAY_INCREASE_ACCESSIBILITY_OF_FIELD": "Using reflection to modify fields can increase accessibility and expose private fields. Avoid this practice.",
    "MC_OVERRIDABLE_METHOD_CALL_IN_CONSTRUCTOR": "Calling overridable methods in constructors can lead to issues with uninitialized data and object state leakage.",
    "MC_OVERRIDABLE_METHOD_CALL_IN_CLONE": "Calling overridable methods in the clone() method can cause issues in object initialization and state.",
    "MC_OVERRIDABLE_METHOD_CALL_IN_READ_OBJECT": "Calling overridable methods in readObject() can affect object initialization during deserialization.",
    "PERM_SUPER_NOT_CALLED_IN_GETPERMISSIONS": "Custom class loaders must call the superclass's getPermissions() method to maintain consistent permissions.",
    "USC_POTENTIAL_SECURITY_CHECK_BASED_ON_UNTRUSTED_SOURCE": "A public method of a public class may be called from outside the package which means that untrusted data may be passed to it. Calling a method before the doPrivileged to check its return value and then calling the same method inside the class is dangerous if the method or its enclosing class is not final. An attacker may pass an instance of a malicious descendant of the class instead of an instance of the expected one where this method is overridden in a way that it returns different values upon different invocations. For example, a method returning a file path may return a harmless path to check before entering the doPrivileged block and then a sensitive file upon the call inside the doPrivileged block. To avoid such scenario defensively copy the object received in the parameter, e.g. by using the copy constructor of the class used as the type of the formal parameter. This ensures that the method behaves exactly as expected.",
    "VSC_VULNERABLE_SECURITY_CHECK_METHODS": "Methods that perform security checks should be prevented from being overridden, so they must be declared as private or final. Otherwise, these methods can be compromised when a malicious subclass overrides them and omits the checks.",
    "MT_CORRECTNESS": "Code flaws having to do with threads, locks, and volatiles",
    "AT_OPERATION_SEQUENCE_ON_CONCURRENT_ABSTRACTION": "This code contains a sequence of calls to a concurrent abstraction (such as a concurrent hash map). These calls will not be executed atomically.",
    "STCAL_STATIC_CALENDAR_INSTANCE": "Even though the JavaDoc does not contain a hint about it, Calendars are inherently unsafe for multithreaded use. Sharing a single instance across thread boundaries without proper synchronization will result in erratic behavior of the application. Under 1.4 problems seem to surface less often than under Java 5 where you will probably see random ArrayIndexOutOfBoundsExceptions or IndexOutOfBoundsExceptions in sun.util.calendar.BaseCalendar.getCalendarDateFromFixedDate(). You may also experience serialization problems. Using an instance field is recommended.",
    "STCAL_STATIC_SIMPLE_DATE_FORMAT_INSTANCE": "As the JavaDoc states, DateFormats are inherently unsafe for multithreaded use. Sharing a single instance across thread boundaries without proper synchronization will result in erratic behavior of the application. You may also experience serialization problems. Using an instance field is recommended.",
    "STCAL_INVOKE_ON_STATIC_CALENDAR_INSTANCE": "Even though the JavaDoc does not contain a hint about it, Calendars are inherently unsafe for multithreaded use. The detector has found a call to an instance of Calendar that has been obtained via a static field. This looks suspicious.",
    "STCAL_INVOKE_ON_STATIC_DATE_FORMAT_INSTANCE": "As the JavaDoc states, DateFormats are inherently unsafe for multithreaded use. The detector has found a call to an instance of DateFormat that has been obtained via a static field. This looks suspicious.",
    "NP_SYNC_AND_NULL_CHECK_FIELD": "Since the field is synchronized on, it seems not likely to be null. If it is null and then synchronized on a NullPointerException will be thrown and the check would be pointless. Better to synchronize on another field.",
    "VO_VOLATILE_REFERENCE_TO_ARRAY": "This declares a volatile reference to an array, which might not be what you want. With a volatile reference to an array, reads and writes of the reference to the array are treated as volatile, but the array elements are non-volatile. To get volatile array elements, you will need to use one of the atomic array classes in java.util.concurrent (provided in Java 5.0).",
    "VO_VOLATILE_INCREMENT": "This code increments/decrements a volatile field. Increments/Decrements of volatile fields aren't atomic. If more than one thread is incrementing/decrementing the field at the same time, increments/decrements could be lost.",
    "DM_MONITOR_WAIT_ON_CONDITION": "This method calls wait() on a java.util.concurrent.locks.Condition object.  Waiting for a Condition should be done using one of the await() methods defined by the Condition interface.",
    "DM_USELESS_THREAD": "This method creates a thread without specifying a run method either by deriving from the Thread class, or by passing a Runnable object. This thread, then, does nothing but waste time.",
    "DC_DOUBLECHECK": "This method may contain an instance of double-checked locking. This idiom is not correct according to the semantics of the Java memory model.",
    "DC_PARTIALLY_CONSTRUCTED": "Looks like this method uses lazy field initialization with double-checked locking. While the field is correctly declared as volatile, it's possible that the internal structure of the object is changed after the field assignment, thus another thread may see the partially initialized object.",
    "DL_SYNCHRONIZATION_ON_SHARED_CONSTANT": "The code synchronizes on String literal. Constant Strings are interned and shared across all other classes loaded by the JVM. Thus, this code is locking on something that other code might also be locking. This could result in very strange and hard to diagnose blocking and deadlock behavior.",
    "DL_SYNCHRONIZATION_ON_BOOLEAN": "The code synchronizes on a boxed primitive constant, such as a Boolean. Since there normally exist only two Boolean objects, this code could be synchronizing on the same object as other, unrelated code, leading to unresponsiveness and possible deadlock.",
    "DL_SYNCHRONIZATION_ON_BOXED_PRIMITIVE": "The code synchronizes on a boxed primitive constant, such as an Integer. Since Integer objects can be cached and shared, this code could be synchronizing on the same object as other, unrelated code, leading to unresponsiveness and possible deadlock.",
    "DL_SYNCHRONIZATION_ON_UNSHARED_BOXED_PRIMITIVE": "The code synchronizes on an apparently unshared boxed primitive, such as an Integer. It would be much better to redeclare fileLock as private static final Object fileLock = new Object();",
    "DL_SYNCHRONIZATION_ON_INTERNED_STRING": "The code synchronizes on interned String. Constant Strings are interned and shared across all other classes loaded by the JVM. This could result in very strange and hard to diagnose blocking and deadlock behavior.",
    "WL_USING_GETCLASS_RATHER_THAN_CLASS_LITERAL": "This instance method synchronizes on this.getClass(). If this class is subclassed, subclasses will synchronize on the class object for the subclass, which isn't likely what was intended. Instead, this code should be synchronizing on Label.class.",
    "ESync_EMPTY_SYNC": "The code contains an empty synchronized block. Empty synchronized blocks are far more subtle and hard to use correctly than most people recognize, and empty synchronized blocks are almost never a better solution than less contrived solutions.",
    "MSF_MUTABLE_SERVLET_FIELD": "A web server generally only creates one instance of servlet or JSP class (i.e., treats the class as a Singleton), and will have multiple threads invoke methods on that instance to service multiple simultaneous requests. Thus, having a mutable instance field generally creates race conditions.",
    "IS": "Inconsistent synchronization (IS2_INCONSISTENT_SYNC) - The fields of this class appear to be accessed inconsistently with respect to synchronization. The class contains a mix of locked and unlocked accesses. It is not annotated as javax.annotation.concurrent.NotThreadSafe. At least one locked access was performed by one of the class's own methods, and the number of unsynchronized field accesses was no more than one third of all accesses.",
    "NN": "Naked notify (NN_NAKED_NOTIFY) - A call to notify() or notifyAll() was made without any accompanying modification to mutable object state. The condition being waited on may not be meaningful unless there is a change to the mutable object state.",
    "RU": "Invokes run on a thread (RU_INVOKE_RUN) - This method explicitly invokes run() on an object, but the method should call Thread.start() to start the thread instead.",
    "SP": "Method spins on field (SP_SPIN_ON_FIELD) - This method spins in a loop which reads a field. The compiler may hoist the read out of the loop, turning the code into an infinite loop. The code should use proper synchronization (including wait and notify calls).",
    "TLW": "Wait with two locks held (TLW_TWO_LOCK_WAIT) - Waiting on a monitor while two locks are held may cause deadlock. Performing a wait only releases the lock on the object being waited on, not any other locks.",
    "UW": "Unconditional wait (UW_UNCOND_WAIT) - This method contains a call to java.lang.Object.wait() which is not guarded by conditional control flow. The code should verify the condition it intends to wait for is not already satisfied before calling wait.",
    "UG": "Unsynchronized get method, synchronized set method (UG_SYNC_SET_UNSYNC_GET) - This class contains similarly-named get and set methods where the set method is synchronized and the get method is not, which may lead to inconsistent object state.",
    "IS_FIELD_NOT_GUARDED": "Field not guarded against concurrent access (IS_FIELD_NOT_GUARDED) - This field is annotated with @GuardedBy but is accessed in a way that violates the annotation.",
    "ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD": "Synchronization on field in futile attempt to guard that field (ML_SYNC_ON_FIELD_TO_GUARD_CHANGING_THAT_FIELD) - Synchronizing on a field does not guard the field itself effectively because it locks the referenced object rather than the field.",
    "ML_SYNC_ON_UPDATED_FIELD": "Method synchronizes on an updated field (ML_SYNC_ON_UPDATED_FIELD) - This method synchronizes on an object referenced from a mutable field, which may not have useful semantics.",
    "WS": "Class’s writeObject() method is synchronized but nothing else is (WS_WRITEOBJECT_SYNC) - This class has a synchronized writeObject() method, but no other method of the class is synchronized, leading to potential inconsistencies in thread safety.",
    "RS": "Class’s readObject() method is synchronized (RS_READOBJECT_SYNC) - This serializable class defines a synchronized readObject(), which is unnecessary because the object is only accessed by a single thread during deserialization.",
    "SC": "Constructor invokes Thread.start() (SC_START_IN_CTOR) - The constructor starts a thread, which can lead to issues when the class is extended, as the thread starts before the subclass constructor.",
    "WA_NOT_IN_LOOP": "Wait not in loop (WA_NOT_IN_LOOP) - This method contains a call to java.lang.Object.wait() not inside a loop. If multiple conditions exist, this can lead to waiting for the wrong condition.",
    "WA_AWAIT_NOT_IN_LOOP": "Condition.await() not in loop (WA_AWAIT_NOT_IN_LOOP) - This method contains a call to await() not inside a loop. Like wait(), this can lead to waiting for the wrong condition if there are multiple conditions.",
    "NO_NOTIFY_NOT_NOTIFYALL": "Using notify() rather than notifyAll() (NO_NOTIFY_NOT_NOTIFYALL) - This method calls notify() instead of notifyAll(), which wakes up only one thread and might not be the one that satisfies the condition.",
    "UL_UNRELEASED_LOCK": "Method does not release lock on all paths (UL_UNRELEASED_LOCK) - This method acquires a lock but does not release it on all paths, including those leading to exceptions.",
    "UL_UNRELEASED_LOCK_EXCEPTION_PATH": "Method does not release lock on all exception paths (UL_UNRELEASED_LOCK_EXCEPTION_PATH) - This method acquires a lock but does not release it on paths leading to exceptions.",
    "MWN_MISMATCHED_WAIT": "Mismatched wait() (MWN_MISMATCHED_WAIT) - This method calls wait() without holding a lock on the object, which will throw an IllegalMonitorStateException.",
    "MWN_MISMATCHED_NOTIFY": "Mismatched notify() (MWN_MISMATCHED_NOTIFY) - This method calls notify() or notifyAll() without holding a lock on the object, which will throw an IllegalMonitorStateException.",
    "LI_LAZY_INIT_STATIC": "Incorrect lazy initialization of static field (LI_LAZY_INIT_STATIC) - This method contains an unsynchronized lazy initialization of a non-volatile static field, leading to potential issues with thread visibility.",
    "LI_LAZY_INIT_UPDATE_STATIC": "Incorrect lazy initialization and update of static field (LI_LAZY_INIT_UPDATE_STATIC) - This method contains an unsynchronized lazy initialization of a static field, followed by further updates to the object stored in that field, which can cause multithreading issues.",
    "JLM_JSR166_UTILCONCURRENT_MONITORENTER": "Synchronization performed on util.concurrent instance (JLM_JSR166_UTILCONCURRENT_MONITORENTER) - This method synchronizes on an object from the java.util.concurrent package, which already provides its own concurrency control mechanisms.",
    "JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT": "Using monitor style wait methods on util.concurrent abstraction (JML_JSR166_CALLING_WAIT_RATHER_THAN_AWAIT) - This method uses wait(), notify() or notifyAll() on objects that also provide await(), signal(), signalAll(), which can be confusing and incorrect.",
    "JLM_JSR166_LOCK_MONITORENTER": "Synchronization performed on Lock (JLM_JSR166_LOCK_MONITORENTER) - This method synchronizes on a Lock object, which should be locked/unlocked using acquire()/release() instead of the synchronized keyword.",
    "SWL_SLEEP_WITH_LOCK_HELD": "Method calls Thread.sleep() with a lock held (SWL_SLEEP_WITH_LOCK_HELD) - This method calls Thread.sleep() with a lock held, potentially leading to poor performance, scalability, or deadlocks. It is better to call wait() instead to release the lock.",
    "RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED": "Return value of putIfAbsent ignored, value passed to putIfAbsent reused (RV_RETURN_VALUE_OF_PUTIFABSENT_IGNORED) - The return value of putIfAbsent is ignored, and the value passed in is reused, which could lead to incorrect program behavior.",
    "SSD_DO_NOT_USE_INSTANCE_LOCK_ON_SHARED_STATIC_DATA": "Instance level lock was used on a shared static data (SSD_DO_NOT_USE_INSTANCE_LOCK_ON_SHARED_STATIC_DATA) - Using an instance lock for shared static data leaves it unprotected against concurrent access. The lock should be static.",
    "NOISE_NULL_DEREFERENCE": "Bogus warning about a null pointer dereference.",
    "NOISE_METHOD_CALL": "Bogus warning about a method call.",
    "NOISE_FIELD_REFERENCE": "Bogus warning about a field reference.",
    "NOISE_OPERATION": "Bogus warning about an operation.",
    "HSC_HUGE_SHARED_STRING_CONSTANT": "A large String constant is duplicated across multiple class files.",
    "DMI_BLOCKING_METHODS_ON_URL": "The equals and hashCode methods of URL perform domain name resolution, resulting in a performance hit.",
    "DMI_COLLECTION_OF_URLS": "Maps and sets of URLs can be performance hogs due to domain name resolution in equals and hashCode.",
    "DM_STRING_CTOR": "Method invokes inefficient new String(String) constructor, wasting memory.",
    "DM_STRING_VOID_CTOR": "Method invokes inefficient new String() constructor, wasting memory.",
    "DM_STRING_TOSTRING": "Calling String.toString() is a redundant operation. Just use the String.",
    "DM_GC": "Code explicitly invokes garbage collection, which is generally dubious except in benchmarking code.",
    "DM_BOOLEAN_CTOR": "Method invokes inefficient Boolean constructor; use Boolean.valueOf() instead.",
    "DM_NUMBER_CTOR": "Method invokes inefficient Number constructor; use static valueOf instead.",
    "DM_FP_NUMBER_CTOR": "Method invokes inefficient floating-point Number constructor; use static valueOf instead.",
    "DM_BOXED_PRIMITIVE_TOSTRING": "A boxed primitive is allocated just to call toString(). Use static toString methods for primitives.",
    "DM_BOXED_PRIMITIVE_FOR_PARSING": "Boxing a primitive to parse it is inefficient. Use static parseXXX methods instead.",
    "DM_BOXED_PRIMITIVE_FOR_COMPARE": "Boxing a primitive to compare it is inefficient. Use static compare methods instead.",
    "BX_UNBOXED_AND_COERCED_FOR_TERNARY_OPERATOR": "A wrapped primitive value is unboxed and coerced for the ternary operator.",
    "BX_UNBOXING_IMMEDIATELY_REBOXED": "A boxed value is unboxed and immediately reboxed.",
    "BX_BOXING_IMMEDIATELY_UNBOXED": "A primitive is boxed and then immediately unboxed.",
    "BX_BOXING_IMMEDIATELY_UNBOXED_TO_PERFORM_COERCION": "A primitive boxed value is unboxed and immediately coerced into another primitive type.",
    "DM_NEW_FOR_GETCLASS": "Method allocates an object just to call getClass() to retrieve the Class object. Use .class instead.",
    "DM_NEXTINT_VIA_NEXTDOUBLE": "Use nextInt(n) rather than nextDouble() to generate a random integer.",
    "SS_SHOULD_BE_STATIC": "This class contains an instance final field initialized to a compile-time static value. Consider making the field static.",
    "UUF_UNUSED_FIELD": "This field is never used. Consider removing it from the class.",
    "URF_UNREAD_FIELD": "This field is never read. Consider removing it from the class.",
    "SIC_INNER_SHOULD_BE_STATIC": "This class is an inner class but does not use its reference to the outer class. Make it static.",
    "SIC_INNER_SHOULD_BE_STATIC_NEEDS_THIS": "This inner class does not use its reference to the outer object except during construction. Refactor to make it static.",
    "SIC_INNER_SHOULD_BE_STATIC_ANON": "This anonymous inner class does not use its reference to the outer object. Refactor into a named static inner class.",
    "UPM_UNCALLED_PRIVATE_METHOD": "This private method is never called. It should be removed.",
    "SBSC_USE_STRINGBUFFER_CONCATENATION": "Method concatenates strings using + in a loop. Use StringBuilder instead for better performance.",
    "IIL_ELEMENTS_GET_LENGTH_IN_LOOP": "The method calls NodeList.getLength() inside the loop and NodeList was produced by getElementsByTagName call. This NodeList doesn't store its length, but computes it every time in not very optimal way. Consider storing the length to the variable before the loop.",
    "IIL_PREPARE_STATEMENT_IN_LOOP": "The method calls Connection.prepareStatement inside the loop passing the constant arguments. If the PreparedStatement should be executed several times there's no reason to recreate it for each loop iteration. Move this call outside of the loop.",
    "IIL_PATTERN_COMPILE_IN_LOOP": "The method calls Pattern.compile inside the loop passing the constant arguments. If the Pattern should be used several times there's no reason to compile it for each loop iteration. Move this call outside of the loop or even into static final field.",
    "IIL_PATTERN_COMPILE_IN_LOOP_INDIRECT": "The method creates the same regular expression inside the loop, so it will be compiled every iteration. It would be more optimal to precompile this regular expression using Pattern.compile outside of the loop.",
    "IIO_INEFFICIENT_INDEX_OF": "This code passes a constant string of length 1 to String.indexOf(). It is more efficient to use the integer implementations of String.indexOf(). f. e. call myString.indexOf('.') instead of myString.indexOf(\".\")",
    "IIO_INEFFICIENT_LAST_INDEX_OF": "This code passes a constant string of length 1 to String.lastIndexOf(). It is more efficient to use the integer implementations of String.lastIndexOf(). f. e. call myString.lastIndexOf('.') instead of myString.lastIndexOf(\".\")",
    "ITA_INEFFICIENT_TO_ARRAY": "This method uses the toArray() method of a collection derived class, and passes in a zero-length prototype array argument. It is more efficient to use myCollection.toArray(new Foo[myCollection.size()]) If the array passed in is big enough to store all of the elements of the collection, then it is populated and returned directly. This avoids the need to create a second array (by reflection) to return as the result.",
    "WMI_WRONG_MAP_ITERATOR": "This method accesses the value of a Map entry, using a key that was retrieved from a keySet iterator. It is more efficient to use an iterator on the entrySet of the map, to avoid the Map.get(key) lookup.",
    "UM_UNNECESSARY_MATH": "This method uses a static method from java.lang.Math on a constant value. This method's result in this case, can be determined statically, and is faster and sometimes more accurate to just use the constant. Methods detected are: abs -any-, acos 0.0 or 1.0, asin 0.0 or 1.0, atan 0.0 or 1.0, atan2 0.0, cbrt 0.0 or 1.0, ceil -any-, cos 0.0, cosh 0.0, exp 0.0 or 1.0, expm1 0.0, floor -any-, log 0.0 or 1.0, log10 0.0 or 1.0, rint -any-, round -any-, sin 0.0, sinh 0.0, sqrt 0.0 or 1.0, tan 0.0, tanh 0.0, toDegrees 0.0 or 1.0, toRadians 0.0.",
    "IMA_INEFFICIENT_MEMBER_ACCESS": "This method of an inner class reads from or writes to a private member variable of the owning class, or calls a private method of the owning class. The compiler must generate a special method to access this private member, causing this to be less efficient. Relaxing the protection of the member variable or method will allow the compiler to treat this as a normal access.",
    "XSS_REQUEST_PARAMETER_TO_SEND_ERROR": "This code directly writes an HTTP parameter to a Server error page (using HttpServletResponse.sendError). Echoing this untrusted input allows for a reflected cross site scripting vulnerability. See http://en.wikipedia.org/wiki/Cross-site_scripting for more information.",
    "XSS_REQUEST_PARAMETER_TO_SERVLET_WRITER": "This code directly writes an HTTP parameter to Servlet output, which allows for a reflected cross site scripting vulnerability. See http://en.wikipedia.org/wiki/Cross-site_scripting for more information.",
    "XSS_REQUEST_PARAMETER_TO_JSP_WRITER": "This code directly writes an HTTP parameter to JSP output, which allows for a cross site scripting vulnerability. See http://en.wikipedia.org/wiki/Cross-site_scripting for more information.",
    "HRS_REQUEST_PARAMETER_TO_HTTP_HEADER": "This code directly writes an HTTP parameter to an HTTP header, which allows for an HTTP response splitting vulnerability. See http://en.wikipedia.org/wiki/HTTP_response_splitting for more information.",
    "HRS_REQUEST_PARAMETER_TO_COOKIE": "This code constructs an HTTP Cookie using an untrusted HTTP parameter. If this cookie is added to an HTTP response, it will allow an HTTP response splitting vulnerability. See http://en.wikipedia.org/wiki/HTTP_response_splitting for more information.",
    "PT_ABSOLUTE_PATH_TRAVERSAL": "The software uses an HTTP request parameter to construct a pathname that should be within a restricted directory, but it does not properly neutralize absolute path sequences such as \"/abs/path\" that can resolve to a location that is outside of that directory. See http://cwe.mitre.org/data/definitions/36.html for more information.",
    "PT_RELATIVE_PATH_TRAVERSAL": "The software uses an HTTP request parameter to construct a pathname that should be within a restricted directory, but it does not properly neutralize sequences such as \"..\" that can resolve to a location that is outside of that directory. See http://cwe.mitre.org/data/definitions/23.html for more information.",
    "DMI_CONSTANT_DB_PASSWORD": "This code creates a database connect using a hardcoded, constant password. Anyone with access to either the source code or the compiled code can easily learn the password.",
    "DMI_EMPTY_DB_PASSWORD": "This code creates a database connect using a blank or empty password. This indicates that the database is not protected by a password.",
    "SQL_NONCONSTANT_STRING_PASSED_TO_EXECUTE": "The method invokes the execute or addBatch method on an SQL statement with a String that seems to be dynamically generated. Consider using a prepared statement instead. It is more efficient and less vulnerable to SQL injection attacks.",
    "SQL_PREPARED_STATEMENT_GENERATED_FROM_NONCONSTANT_STRING": "The code creates an SQL prepared statement from a nonconstant String. If unchecked, tainted data from a user is used in building this String, SQL injection could be used to make the prepared statement do something unexpected and undesirable.",
    "ASE_ASSERTION_WITH_SIDE_EFFECT": "Expressions used in assertions must not produce side effects. See SEI CERT Rule EXP06 for more information.",
    "ASE_ASSERTION_WITH_SIDE_EFFECT_METHOD": "Expressions used in assertions must not produce side effects. See SEI CERT Rule EXP06 for more information.",
    "STYLE": "Code that is confusing, anomalous, or written in a way that leads itself to errors. Examples include dead local stores, switch fall through, unconfirmed casts, and redundant null check of value known to be null. More false positives accepted.",
    "CAA_COVARIANT_ARRAY_FIELD": "Array of covariant type is assigned to a field. This is confusing and may lead to ArrayStoreException at runtime if the reference of some other type will be stored in this array later.",
    "CAA_COVARIANT_ARRAY_RETURN": "Array of covariant type is returned from the method. This is confusing and may lead to ArrayStoreException at runtime if the calling code will try to store the reference of some other type in the returned array.",
    "CAA_COVARIANT_ARRAY_LOCAL": "Array of covariant type is assigned to a local variable. This is confusing and may lead to ArrayStoreException at runtime if the reference of some other type will be stored in this array later.",
    "DMI_UNSUPPORTED_METHOD": "All targets of this method invocation throw an UnsupportedOperationException.",
    "DMI_THREAD_PASSED_WHERE_RUNNABLE_EXPECTED": "A Thread object is passed as a parameter to a method where a Runnable is expected. This is rather unusual, and may indicate a logic error or cause unexpected behavior.",
    "NP_DEREFERENCE_OF_READLINE_VALUE": "The result of invoking readLine() is dereferenced without checking to see if the result is null. If there are no more lines of text to read, readLine() will return null and dereferencing that will generate a null pointer exception.",
    "NP_IMMEDIATE_DEREFERENCE_OF_READLINE": "The result of invoking readLine() is immediately dereferenced. If there are no more lines of text to read, readLine() will return null and dereferencing that will generate a null pointer exception.",
    "RV_REM_OF_RANDOM_INT": "This code generates a random signed integer and then computes the remainder of that value modulo another value. Since the random number can be negative, the result of the remainder operation can also be negative. Be sure this is intended, and strongly consider using the Random.nextInt(int) method instead.",
    "RV_REM_OF_HASHCODE": "This code computes a hashCode, and then computes the remainder of that value modulo another value. Since the hashCode can be negative, the result of the remainder operation can also be negative. If you want to ensure a non-negative result, take the absolute value or use bitwise operations if applicable.",
    "EQ_UNUSUAL": "This class doesn't do any of the patterns we recognize for checking that the type of the argument is compatible with the type of the this object. There might not be anything wrong with this code, but it is worth reviewing.",
    "EQ_DOESNT_OVERRIDE_EQUALS": "This class extends a class that defines an equals method and adds fields, but doesn't define an equals method itself. Thus, equality on instances of this class will ignore the identity of the subclass and the added fields. Be sure this is what is intended.",
    "NS_NON_SHORT_CIRCUIT": "This code seems to be using non-short-circuit logic (e.g., & or |) rather than short-circuit logic (&& or ||). Non-short-circuit logic causes both sides of the expression to be evaluated even when the result can be inferred from knowing the left-hand side.",
    "NS_DANGEROUS_NON_SHORT_CIRCUIT": "This code seems to be using non-short-circuit logic (e.g., & or |) rather than short-circuit logic (&& or ||). In addition, it seems possible that, depending on the value of the left-hand side, you might not want to evaluate the right-hand side.",
    "IC_INIT_CIRCULARITY": "A circularity was detected in the static initializers of the two classes referenced by the bug instance. Many kinds of unexpected behavior may arise from such circularity.",
    "IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD": "An inner class is invoking a method that could be resolved to either an inherited method or a method defined in an outer class. This could lead to ambiguity in the method invocation.",
    "SE_PRIVATE_READ_RESOLVE_NOT_INHERITED": "This class defines a private readResolve method. Since it is private, it won't be inherited by subclasses. This might be intentional and OK, but should be reviewed to ensure it is what is intended.",
    "SE_TRANSIENT_FIELD_OF_NONSERIALIZABLE_CLASS": "The field is marked as transient, but the class isn't Serializable, so marking it as transient has absolutely no effect. This may indicate a misunderstanding of how serialization works.",
    "SF_SWITCH_FALLTHROUGH": "This method contains a switch statement where one case branch will fall through to the next case. Usually, you need to end this case with a break or return.",
    "SF_SWITCH_NO_DEFAULT": "This method contains a switch statement where the default case is missing. Usually, you need to provide a default case.",
    "UUF_UNUSED_PUBLIC_OR_PROTECTED_FIELD": "This field is never used. If it is not intended to be used elsewhere, consider removing it from the class.",
    "URF_UNREAD_PUBLIC_OR_PROTECTED_FIELD": "This field is never read. If it is not intended to be used elsewhere, consider removing it from the class.",
    "QF_QUESTIONABLE_FOR_LOOP": "Are you sure this for loop is incrementing or decrementing the correct variable? It appears that another variable is being initialized and checked by the for loop.",
    "NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD": "The program is dereferencing a public or protected field that does not seem to ever have a non-null value written to it. Dereferencing this will generate a null pointer exception.",
    "UWF_FIELD_NOT_INITIALIZED_IN_CONSTRUCTOR": "This field is never initialized within any constructor, and could be null after the object is constructed. Elsewhere, it is loaded and dereferenced without a null check, potentially causing a null pointer exception.",
    "UWF_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD": "No writes were seen to this public/protected field. All reads will return the default value, which could indicate an error or unnecessary field.",
    "UC_USELESS_VOID_METHOD": "This non-empty void method does not actually perform any useful work. Please check if there is a mistake in its code or if its body can be removed.",
    "UC_USELESS_CONDITION": "This condition always produces the same result as the value of the involved variable that was narrowed before. Probably something else was meant or the condition can be removed.",
    "UC_USELESS_CONDITION_TYPE": "This condition always produces the same result due to the type range of the involved variable. Probably something else was meant or the condition can be removed.",
    "UC_USELESS_OBJECT": "Our analysis shows that this object is useless. It's created and modified, but its value never goes outside of the method or produces any side effect. Either there is a mistake and the object was intended to be used or it can be removed.",
    "UC_USELESS_OBJECT_STACK": "This object is created just to perform some modifications which don't have any side effect. Probably something else was meant or the object can be removed.",
    "RV_RETURN_VALUE_IGNORED_INFERRED": "This code calls a method and ignores the return value. The return value is the same type as the type the method is invoked on, and from our analysis it looks like the return value might be important.",
    "RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT": "This code calls a method and ignores the return value. However, our analysis shows that the method (including its implementations in subclasses if any) does not produce any effect other than return value.",
    "RV_CHECK_FOR_POSITIVE_INDEXOF": "The method invokes String.indexOf and checks to see if the result is positive or non-positive. It is much more typical to check to see if the result is negative or non-negative.",
    "RV_DONT_JUST_NULL_CHECK_READLINE": "The value returned by readLine is discarded after checking to see if the return value is non-null. In almost all situations, if the result is non-null, you will want to use that non-null value.",
    "NP_PARAMETER_MUST_BE_NONNULL_BUT_MARKED_AS_NULLABLE": "This parameter is always used in a way that requires it to be non-null, but the parameter is explicitly annotated as being Nullable. Either the use of the parameter or the annotation is wrong.",
    "NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE": "The return value from a method is dereferenced without a null check, and the return value of that method is one that should generally be checked for null. This may lead to a NullPointerException when the code is executed.",
    "NP_NULL_ON_SOME_PATH_MIGHT_BE_INFEASIBLE": "There is a branch of statement that, if executed, guarantees that a null value will be dereferenced, which would generate a NullPointerException when the code is executed.",
    "NP_LOAD_OF_KNOWN_NULL_VALUE": "The variable referenced at this point is known to be null due to an earlier check against null. Although this is valid, it might be a mistake.",
    "PZLA_PREFER_ZERO_LENGTH_ARRAYS": "It is often a better design to return a length zero array rather than a null reference to indicate that there are no results.",
    "UCF_USELESS_CONTROL_FLOW": "This method contains a useless control flow statement, where control flow continues onto the same place regardless of whether or not the branch is taken.",
    "UCF_USELESS_CONTROL_FLOW_NEXT_LINE": "This method contains a useless control flow statement in which control flow follows to the same or following line regardless of whether or not the branch is taken.",
    "RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE": "This method contains a redundant check of a known null value against the constant null.",
    "RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE": "This method contains a redundant check of a known non-null value against the constant null.",
    "RCN_REDUNDANT_COMPARISON_TWO_NULL_VALUES": "This method contains a redundant comparison of two references known to both be definitely null.",
    "RCN_REDUNDANT_COMPARISON_OF_NULL_AND_NONNULL_VALUE": "This method contains a reference known to be non-null with another reference known to be null.",
    "SA_LOCAL_SELF_ASSIGNMENT": "This method contains a self assignment of a local variable.",
    "INT_BAD_REM_BY_1": "Any expression (exp % 1) is guaranteed to always return zero. Did you mean (exp & 1) or (exp % 2) instead?",
    "INT_VACUOUS_COMPARISON": "There is an integer comparison that always returns the same value.",
    "INT_VACUOUS_BIT_OPERATION": "This is an integer bit operation (and, or, or exclusive or) that doesn't do any useful work.",
    "SA_LOCAL_DOUBLE_ASSIGNMENT": "This method contains a double assignment of a local variable.",
    "SA_FIELD_DOUBLE_ASSIGNMENT": "This method contains a double assignment of a field.",
    "DLS_DEAD_LOCAL_STORE_IN_RETURN": "This statement assigns to a local variable in a return statement. This assignment has no effect.",
    "DLS_DEAD_LOCAL_STORE": "This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction.",
    "DLS_DEAD_LOCAL_STORE_SHADOWS_FIELD": "This instruction assigns a value to a local variable, but the value is not read or used in any subsequent instruction. There is a field with the same name as the local variable.",
    "DLS_DEAD_LOCAL_STORE_OF_NULL": "The code stores null into a local variable, and the stored value is not read.",
    "REC_CATCH_EXCEPTION": "This method uses a try-catch block that catches Exception objects, but Exception is not thrown within the try block.",
    "DCN_NULLPOINTER_EXCEPTION": "This non-compliant code catches a NullPointerException to see if an incoming parameter is null.",
    "FE_FLOATING_POINT_EQUALITY": "This operation compares two floating point values for equality. Because floating point calculations may involve rounding, calculated float and double values may not be accurate.",
    "CD_CIRCULAR_DEPENDENCY": "This class has a circular dependency with other classes. This makes building these classes difficult.",
    "RI_REDUNDANT_INTERFACES": "This class declares that it implements an interface that is also implemented by a superclass. This is redundant.",
    "MTIA_SUSPECT_STRUTS_INSTANCE_FIELD": "This class extends from a Struts Action class, and uses an instance member variable. Since only one instance of a struts Action class is created by the Struts framework, and used in a multithreaded way, this paradigm is highly discouraged and most likely problematic. Consider only using method local variables. Only instance fields that are written outside of a monitor are reported.",
    "MTIA_SUSPECT_SERVLET_INSTANCE_FIELD": "This class extends from a Servlet class, and uses an instance member variable. Since only one instance of a Servlet class is created by the J2EE framework, and used in a multithreaded way, this paradigm is highly discouraged and most likely problematic. Consider only using method local variables.",
    "PS_PUBLIC_SEMAPHORES": "This class uses synchronization along with wait(), notify() or notifyAll() on itself (the this reference). Client classes that use this class, may, in addition, use an instance of this class as a synchronizing object. Because two classes are using the same object for synchronization, Multithread correctness is suspect. You should not synchronize nor call semaphore methods on a public reference. Consider using an internal private member variable to control synchronization.",
    "ICAST_INTEGER_MULTIPLY_CAST_TO_LONG": "This code performs integer multiply and then converts the result to a long. If the multiplication is done using long arithmetic, you can avoid the possibility that the result will overflow. For example, you could fix the code by using long arithmetic or using a constant long value.",
    "ICAST_IDIV_CAST_TO_DOUBLE": "This code casts the result of an integral division (e.g., int or long division) operation to double or float. It’s likely that one or both operands should be cast to double before performing the division.",
    "BC_BAD_CAST_TO_CONCRETE_COLLECTION": "This code casts an abstract collection (such as a Collection, List, or Set) to a specific concrete implementation (such as an ArrayList or HashSet). This might not be correct, and it makes it harder to switch to other concrete implementations.",
    "BC_UNCONFIRMED_CAST": "This cast is unchecked, and not all instances of the type cast from can be cast to the type it is being cast to. Check that your program logic ensures that this cast will not fail.",
    "BC_UNCONFIRMED_CAST_OF_RETURN_VALUE": "This code performs an unchecked cast of the return value of a method. The code might be calling the method in such a way that the cast is guaranteed to be safe, but SpotBugs is unable to verify that the cast is safe.",
    "BC_VACUOUS_INSTANCEOF": "This instanceof test will always return true (unless the value being tested is null). Although this is safe, make sure it isn't an indication of some misunderstanding or logic error.",
    "BC_BAD_CAST_TO_ABSTRACT_COLLECTION": "This code casts a Collection to an abstract collection (such as List, Set, or Map). Ensure that you are guaranteed that the object is of the type you are casting to.",
    "IM_BAD_CHECK_FOR_ODD": "The code uses x % 2 == 1 to check to see if a value is odd, but this won't work for negative numbers. Consider using (x & 1) == 1, or x % 2 != 0.",
    "IM_AVERAGE_COMPUTATION_COULD_OVERFLOW": "The code computes the average of two integers and then uses the result as the index of an array. If the values being averaged are large, this can overflow, causing incorrect results. Use unsigned right shift for proper computation.",
    "ICAST_QUESTIONABLE_UNSIGNED_RIGHT_SHIFT": "The code performs an unsigned right shift, whose result is then cast to a short or byte, discarding the upper bits. This can lead to unexpected results, especially with larger shifts.",
    "DMI_HARDCODED_ABSOLUTE_FILENAME": "This code constructs a File object using a hard coded absolute pathname. This makes the code brittle, as it cannot be easily portable to other environments.",
    "DMI_USELESS_SUBSTRING": "This code invokes substring(0) on a String, which just returns the original value. This is unnecessary and should be removed.",
    "ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD": "This instance method writes to a static field. This can cause issues in multi-instance scenarios and is generally bad practice.",
    "DMI_NONSERIALIZABLE_OBJECT_WRITTEN": "This code seems to be passing a non-serializable object to the ObjectOutput.writeObject method, which will result in an error if the object is indeed non-serializable.",
    "DB_DUPLICATE_BRANCHES": "This method uses the same code to implement two branches of a conditional branch. Check to ensure that this isn't a coding mistake.",
    "DB_DUPLICATE_SWITCH_CLAUSES": "This method uses the same code to implement two clauses of a switch statement. This could be a case of duplicate code, but it might also indicate a coding mistake.",
    "XFB_XML_FACTORY_BYPASS": "This method allocates a specific implementation of an XML interface. It is better to use the provided factory classes to create these objects so that the implementation can be changed at runtime.",
    "USM_USELESS_SUBCLASS_METHOD": "This derived method merely calls the same superclass method passing in the exact parameters received. This method can be removed as it provides no additional value.",
    "USM_USELESS_ABSTRACT_METHOD": "This abstract method is already defined in an interface that is implemented by this abstract class. This method can be removed as it provides no additional value.",
    "CI_CONFUSED_INHERITANCE": "This class is declared as final but declares fields as protected. Since the class is final, it cannot be inherited, and the protected modifier is confusing. The field should be private or public.",
    "TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_NEVER_SINK": "A value is used in a way that requires it to never have a certain type qualifier, but there is an explicit annotation stating it is not known where the value should not have that qualifier.",
    "TQ_EXPLICIT_UNKNOWN_SOURCE_VALUE_REACHES_ALWAYS_SINK": "A value is used in a way that requires it to always have a certain type qualifier, but there is an explicit annotation stating it is not known where the value should always have that qualifier.",
    "NP_METHOD_RETURN_RELAXING_ANNOTATION": "A method should always implement the contract of a method it overrides. If a method is annotated to return @Nonnull, you shouldn't override it with a method returning @Nullable.",
    "NP_METHOD_PARAMETER_TIGHTENS_ANNOTATION": "A method should always implement the contract of a method it overrides. If a method takes a parameter marked @Nullable, you shouldn't override it with a method where that parameter is @Nonnull."
}     
  

